<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Jvm | zarue]]></title>
  <link href="http://blog.zarue.com//blog/categories/jvm/atom.xml" rel="self"/>
  <link href="http://blog.zarue.com//"/>
  <updated>2014-06-14T17:07:27+08:00</updated>
  <id>http://blog.zarue.com//</id>
  <author>
    <name><![CDATA[YungHua.Ma]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JVM 之 Java对象创建[加载和连接]]]></title>
    <link href="http://blog.zarue.com//blog/2014/06/14/java-object-create-1/"/>
    <updated>2014-06-14T08:53:49+08:00</updated>
    <id>http://blog.zarue.com//blog/2014/06/14/java-object-create-1</id>
    <content type="html"><![CDATA[<p>Java对象的生命周期可以分为：加载，验证，准备，解析，初始化，使用，卸载 八个阶段。其中验证，准备，解析又被统称为连接，今天主要看一下加载和连接，下一篇文章讲初始化。<br/>
<img src="/images/blog/2014-06/20140614-java-load-pic.png" alt="对象生命周期" /><br/>
说明：本文章所涉及的代码Gist地址:<a href="https://gist.github.com/zarue/0d5f83fa8458a9298b9d">点击查看</a></p>

<!--more-->


<p>要想了解jvm底层的对象创建过程，还是要首先找到一个入口。new关键字无疑是最先想到的，但是看着这段代码“new Animal()” ,我还是找不到什么有用的信息，于是又想到了另一种方式。自定义classloader。<br/>
```java
public class Animal {</p>

<pre><code>String name;

Integer age;

public void run(){

}
</code></pre>

<p>}
<code>
关于自定义classloader 的文章，一搜一大堆，这里就不多说了。我自己定义了一个简单的Classloader。代码：  
</code>java
public class ClassLoaderTest extends ClassLoader {</p>

<pre><code>@Override
protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
    byte[] classBytes = null;
    try {
        InputStream is = new FileInputStream(new File(name));
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        byte[] buffer = new byte[256];
        int length = 0;
        while((length = is.read(buffer))!=-1){
            bos.write(buffer, 0, length);
        }
        classBytes = bos.toByteArray();
        bos.close();
        is.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
    if(classBytes==null){
        throw new ClassNotFoundException("class not found:"+name);
    }
    return defineClass(name, classBytes, 0, classBytes.length);
}

public static void main(String args[]){
    ClassLoaderTest clt = new ClassLoaderTest();
    try {
        Class claszz = clt.loadClass("Animal");
        Animal animal = (Animal)claszz.newInstance();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>}
<code>
findClass（） 方法主要是加载class文件,然后调用defineClass（...）。  
看一下defineClass(...)的代码:  
</code>java
protected final Class&lt;?> defineClass(String name, byte[] b, int off, int len,</p>

<pre><code>                                     ProtectionDomain protectionDomain)
    throws ClassFormatError
{
    protectionDomain = preDefineClass(name, protectionDomain);

    Class c = null;
    String source = defineClassSourceLocation(protectionDomain);

    try {
        c = defineClass1(name, b, off, len, protectionDomain, source);
    } catch (ClassFormatError cfe) {
        c = defineTransformedClass(name, b, off, len, protectionDomain, cfe,
                                   source);
    }

    postDefineClass(c, protectionDomain);
    return c;
}
</code></pre>

<p><code>
第5行：`preDefineClass(name, protectionDomain);`主要是进行一些预处理，比如检查名字是否合法，证书是否正确等等。有兴趣的自己看一下。  
第11行：`defineClass1(...)`调用了native方法，这个方法位于：/share/native/java/lang/ClassLoader.c中。  
</code>java
Java_java_lang_ClassLoader_defineClass1(JNIEnv *env,</p>

<pre><code>                                    jobject loader,
                                    jstring name,
                                    jbyteArray data,
                                    jint offset,
                                    jint length,
                                    jobject pd,
                                    jstring source)
</code></pre>

<p>{</p>

<pre><code>jbyte *body;
char *utfName;
jclass result = 0;
char buf[128];
char* utfSource;
char sourceBuf[1024];

if (data == NULL) {
    JNU_ThrowNullPointerException(env, 0);
    return 0;
}
</code></pre>

<p> if (length &lt; 0) {</p>

<pre><code>    JNU_ThrowArrayIndexOutOfBoundsException(env, 0);
    return 0;
}

body = (jbyte *)malloc(length);

if (body == 0) {
    JNU_ThrowOutOfMemoryError(env, 0);
    return 0;
}

(*env)-&gt;GetByteArrayRegion(env, data, offset, length, body);

if ((*env)-&gt;ExceptionOccurred(env))
    goto free_body;

if (name != NULL) {
    utfName = getUTF(env, name, buf, sizeof(buf));
    if (utfName == NULL) {
        JNU_ThrowOutOfMemoryError(env, NULL);
        goto free_body;
    }
    VerifyFixClassname(utfName);
} else {
    utfName = NULL;
}

if (source != NULL) {
    utfSource = getUTF(env, source, sourceBuf, sizeof(sourceBuf));
    if (utfSource == NULL) {
        JNU_ThrowOutOfMemoryError(env, NULL);
        goto free_utfName;
    }
} else {
    utfSource = NULL;
}
result = JVM_DefineClassWithSource(env, utfName, loader, body, length, pd, utfSource);

if (utfSource &amp;&amp; utfSource != sourceBuf)
    free(utfSource);
</code></pre>

<p> free_utfName:</p>

<pre><code>if (utfName &amp;&amp; utfName != buf)
    free(utfName);
</code></pre>

<p> free_body:</p>

<pre><code>free(body);
return result;
</code></pre>

<p>}
<code>
第33行：`(*env)-&gt;GetByteArrayRegion(env, data, offset, length, body);`把传进来的clas对应的字节数组复制给body。`GetByteArrayRegion`此函数将Java传来的字节数组data，复制offset-&gt;length长度的数据给body。  
第39行：把name转为UTF格式。  
第58行：`JVM_DefineClassWithSource(env, utfName, loader, body, length, pd, utfSource);`该方法位于:`/share/vm/prims/jvm.cpp`   
</code>java
JVM_ENTRY(jclass, JVM_DefineClassWithSource(JNIEnv <em>env, const char </em>name, jobject loader, const jbyte <em>buf,
 jsize len, jobject pd, const char </em>source))
JVMWrapper2(&ldquo;JVM_DefineClassWithSource %s&rdquo;, name);</p>

<p>return jvm_define_class_common(env, name, loader, buf, len, pd, source, true, THREAD);
JVM_END
<code>
调用了`jvm_define_class_common(...) `方法:  
</code>java
static jclass jvm_define_class_common(JNIEnv <em>env, const char </em>name,</p>

<pre><code>                                  jobject loader, const jbyte *buf,
                                  jsize len, jobject pd, const char *source,
                                  jboolean verify, TRAPS) {
</code></pre>

<p>  if (source == NULL)  source = &ldquo;<strong>JVM_DefineClass</strong>&rdquo;;</p>

<p>  assert(THREAD->is_Java_thread(), &ldquo;must be a JavaThread&rdquo;);
  JavaThread<em> jt = (JavaThread</em>) THREAD;</p>

<p>  PerfClassTraceTime vmtimer(ClassLoader::perf_define_appclass_time(),</p>

<pre><code>                         ClassLoader::perf_define_appclass_selftime(),
                         ClassLoader::perf_define_appclasses(),
                         jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
                         jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
                         PerfClassTraceTime::DEFINE_CLASS);
</code></pre>

<p>  if (UsePerfData) {</p>

<pre><code>ClassLoader::perf_app_classfile_bytes_read()-&gt;inc(len);
</code></pre>

<p>  }</p>

<p>  // Since exceptions can be thrown, class initialization can take place
  // if name is NULL no check for class name in .class stream has to be made.
  symbolHandle class_name;
  if (name != NULL) {</p>

<pre><code>const int str_len = (int)strlen(name);
if (str_len &gt; symbolOopDesc::max_length()) {
  // It's impossible to create this class;  the name cannot fit
  // into the constant pool.
  THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), name);
}
class_name = oopFactory::new_symbol_handle(name, str_len, CHECK_NULL);
</code></pre>

<p>  }</p>

<p>  ResourceMark rm(THREAD);
  ClassFileStream st((u1<em>) buf, len, (char </em>)source);
  Handle class_loader (THREAD, JNIHandles::resolve(loader));
  if (UsePerfData) {</p>

<pre><code>is_lock_held_by_thread(class_loader,
                       ClassLoader::sync_JVMDefineClassLockFreeCounter(),
                       THREAD);
</code></pre>

<p>  }
  Handle protection_domain (THREAD, JNIHandles::resolve(pd));
  klassOop k = SystemDictionary::resolve_from_stream(class_name, class_loader,</p>

<pre><code>                                                 protection_domain, &amp;st,
                                                 verify != 0,
                                                 CHECK_NULL);
</code></pre>

<p>  if (TraceClassResolution &amp;&amp; k != NULL) {</p>

<pre><code>trace_class_resolution(k);
</code></pre>

<p>  }</p>

<p>  return (jclass) JNIHandles::make_local(env, Klass::cast(k)&ndash;>java_mirror());
}</p>

<p><code>
第35行：把传入的字节数组转换为`ClassFileStream `对象，以后所有的class数据的提取，分析，验证，转换等都将依托于该对象，和之前的数组没有关系了。  
第43行：调用`SystemDictionary::resolve_from_stream(...)`进行class对象的解析工作。该方法位于：`share/vm/classfile/systemDictionary.cpp`  
看一下这个方法里面的几行主要代码：  
</code>java
instanceKlassHandle k = ClassFileParser(st).parseClassFile(class_name,</p>

<pre><code>                                                         class_loader,
                                                         protection_domain,
                                                         parsed_name,
                                                         verify,
                                                         THREAD);
</code></pre>

<p><code>
调用了ClassFileParser的parseClassFile方法，这个方法里面完成Class对象的构建过程。代码位置:`src/share/vm/classfile/classFileParser.cpp`  
说道这里就要了解一下Class文件的格式了，[Java语言规范](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html)中是这么规定的,其实单讲这个格式也够写一篇文章的，这里不深入，有兴趣的自己网上搜吧。  
</code>java
ClassFile {</p>

<pre><code>u4             magic;
u2             minor_version;
u2             major_version;
u2             constant_pool_count;
cp_info        constant_pool[constant_pool_count-1];
u2             access_flags;
u2             this_class;
u2             super_class;
u2             interfaces_count;
u2             interfaces[interfaces_count];
u2             fields_count;
field_info     fields[fields_count];
u2             methods_count;
method_info    methods[methods_count];
u2             attributes_count;
attribute_info attributes[attributes_count];
</code></pre>

<p>}
<code>
再回到parseClassFile方法：  
</code>java
u4 magic = cfs->get_u4_fast();
  guarantee_property(magic == JAVA_CLASSFILE_MAGIC,</p>

<pre><code>                 "Incompatible magic value %u in class file %s",
                 magic, CHECK_(nullHandle));
</code></pre>

<p><code>
对照上面的Class格式规范，首先获取magic标识(4字节)，然后判断它是不是等于CAFEBABE，如果不等于，则说明不是一个正确的Class文件格式。  
</code>java
// Version numbers
  u2 minor_version = cfs->get_u2_fast();
  u2 major_version = cfs->get_u2_fast();
  if (!is_supported_version(major_version, minor_version)) {</p>

<pre><code>if (name.is_null()) {
  Exceptions::fthrow(
    THREAD_AND_LOCATION,
    vmSymbolHandles::java_lang_UnsupportedClassVersionError(),
    "Unsupported major.minor version %u.%u",
    major_version,
    minor_version);
} else {
  ResourceMark rm(THREAD);
  Exceptions::fthrow(
    THREAD_AND_LOCATION,
    vmSymbolHandles::java_lang_UnsupportedClassVersionError(),
    "%s : Unsupported major.minor version %u.%u",
    name-&gt;as_C_string(),
    major_version,
    minor_version);
}
return nullHandle;
</code></pre>

<p>  }</p>

<p><code>
获得Class文件的版本号，分为主版本号和次版本号。然后判断当前的JVM版本支不支持此版本的Class文件的解析。  
接下来就是常量池了，每一个Class对象里面都有一个对应的常量池(ConstantPoolOop)对象，用来存放Class中的常量。看一下`ClassFileParser::parse_constant_pool(.)`中的部分代码。   
</code>java
parse_constant_pool_entries(cp, length, CHECK_(nullHandle));
<code>
调用parse_constant_pool_entries(...)对象来创建常量池项：  
看一下` ClassFileParser::parse_constant_pool_entries(constantPoolHandle cp, int length, TRAPS)`中的部分代码：  
</code>java
case JVM_CONSTANT_Class :</p>

<pre><code>    {
      cfs-&gt;guarantee_more(3, CHECK);  // name_index, tag/access_flags
      u2 name_index = cfs-&gt;get_u2_fast();
      cp-&gt;klass_index_at_put(index, name_index);
    }
    break;
</code></pre>

<p><code>
常量池对象constantPoolOop使用一个`typeArrayOop`来存储常量池项，回到上面的代码，首先判断剩余的字节数是否满足一个`JVM_CONSTANT_Class`要求的字节数(通过Class文件规范可知是3),然后是获得u2长度的字节数作为name的真实值在常量池中对应的index(Animal的常量池可以参考[Animal常量池](https://gist.github.com/zarue/0d5f83fa8458a9298b9d#file-3-animal-javap))。  
再来看一个：  
</code>java
case JVM_CONSTANT_Utf8 :</p>

<pre><code>    {
      cfs-&gt;guarantee_more(2, CHECK);  // utf8_length
      u2  utf8_length = cfs-&gt;get_u2_fast();
      u1* utf8_buffer = cfs-&gt;get_u1_buffer();
      assert(utf8_buffer != NULL, "null utf8 buffer");
      // Got utf8 string, guarantee utf8_length+1 bytes, set stream position forward.
      cfs-&gt;guarantee_more(utf8_length+1, CHECK);  // utf8 string, tag/access_flags
      cfs-&gt;skip_u1_fast(utf8_length);

      // Before storing the symbol, make sure it's legal
      if (_need_verify) {
        verify_legal_utf8((unsigned char*)utf8_buffer, utf8_length, CHECK);
      }

      if (AnonymousClasses &amp;&amp; has_cp_patch_at(index)) {
        Handle patch = clear_cp_patch_at(index);
        guarantee_property(java_lang_String::is_instance(patch()),
                           "Illegal utf8 patch at %d in class file %s",
                           index, CHECK);
        char* str = java_lang_String::as_utf8_string(patch());
        // (could use java_lang_String::as_symbol instead, but might as well batch them)
        utf8_buffer = (u1*) str;
        utf8_length = (int) strlen(str);
      }

      unsigned int hash;
      symbolOop result = SymbolTable::lookup_only((char*)utf8_buffer, utf8_length, hash);
      if (result == NULL) {
        names[names_count] = (char*)utf8_buffer;
        lengths[names_count] = utf8_length;
        indices[names_count] = index;
        hashValues[names_count++] = hash;
        if (names_count == SymbolTable::symbol_alloc_batch_size) {
          oopFactory::new_symbols(cp, names_count, names, lengths, indices, hashValues, CHECK);
          names_count = 0;
        }
      } else {
        cp-&gt;symbol_at_put(index, result);
      }
    }
    break;
</code></pre>

<p><code>
这是Utf-8类型常量的处理方式，首先检查`SymbolTable`中是否存在该字符串，如果存在就返回已经存在的字符串对象。如果不存在，首先调用`oopFactory::new_symbols(...)`创建一个symbol对象，然后将它加入到SymbolTable中。这样就保证了同样的符号在jvm中仅仅会存在一个对象，可以大大节省存储空间。这里和之前讲的字符串池是一样的处理方式。   
常量池项解析完成之后，我们回到`ClassFileParser::parse_constant_pool(.)`方法，接下来是对转换完成的常量池项进行检查，如果全部检查通过，则返回该常量池对象。  
然后再回到`ClassFileParser::parseClassFile(...)`方法。  
接下来会接着解析`access_flag`,`this_class`,`super_class`等项,具体看源代码即可。
全都解析，验证完了之后，会创建一个描述这个类的对象即:instanceKlass来存储上面解析出来的各个项。instanceKlass的结构如下：  
</code>java</p>

<pre><code>instanceKlass layout:
[header                     ] klassOop
[klass pointer              ] klassOop
[C++ vtbl pointer           ] Klass
[subtype cache              ] Klass
[instance size              ] Klass
[java mirror                ] Klass
[super                      ] Klass
[access_flags               ] Klass
[name                       ] Klass
[first subklass             ] Klass
[next sibling               ] Klass
[array klasses              ]
[methods                    ]
[local interfaces           ]
[transitive interfaces      ]
[number of implementors     ]
[implementors               ] klassOop[2]
[fields                     ]
[constants                  ]
[class loader               ]
[protection domain          ]
[signers                    ]
[source file name           ]
[inner classes              ]
[static field size          ]
[nonstatic field size       ]
[static oop fields size     ]
[nonstatic oop maps size    ]
[has finalize method        ]
[deoptimization mark bit    ]
[initialization state       ]
[initializing thread        ]
[Java vtable length         ]
[oop map cache (stack maps) ]
[EMBEDDED Java vtable             ] size in words = vtable_len
[EMBEDDED static oop fields       ] size in words = static_oop_fields_size
[         static non-oop fields   ] size in words = static_field_size - static_oop_fields_size
[EMBEDDED nonstatic oop-map blocks] size in words = nonstatic_oop_map_size
</code></pre>

<p><code>
然后是初始化静态变量(准备):  
</code>java
 // Initialize static fields</p>

<pre><code>this_klass-&gt;do_local_static_fields(&amp;initialize_static_field, CHECK_(nullHandle));
</code></pre>

<p>```
然后经过一系列的验证，验证通过之后返回该对象。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM 之 String 常量池 二]]></title>
    <link href="http://blog.zarue.com//blog/2014/05/29/runtime-string-pool-2/"/>
    <updated>2014-05-29T20:58:21+08:00</updated>
    <id>http://blog.zarue.com//blog/2014/05/29/runtime-string-pool-2</id>
    <content type="html"><![CDATA[<p>上一篇文章<a href="/blog/2014/05/27/runtime-string-pool-1">JVM 之 String 常量池 一</a>中我们了解到JVM中有一个叫String常量池的东西，String常量池到底是什么样？，又是怎样工作的呢？今天就来看一下。<br/>
做任何事情都要首先找一个入口。我们怎么才能找到常量池的入口呢？<br/>
我们首先想到String里面有个intern方法，可以在运行时向常量池中动态添加字符串。我们就从这个方法入手。<br/>
先看String 的intern的源代码:<br/>
<code>java
public native String intern();
</code>
这是一个native 方法，也就是这个方法不是用java实现的，要找到这个native 方法就要去<a href="http://openjdk.java.net/">JDK的源代码</a>中查找，它位于<code>openjdk/jdk/src/share/native/java/lang</code>目录中的<code>String.c</code>中。这个目录下还有许多其他java类中对应的native方法的实现，例如object类中的<code>hashCode</code>,<code>getClass</code>,<code>clone</code>等方法都在<code>Object.c</code>里面。 <br/>
String.c 中只有一个方法：<br/>
```java</p>

<h1>include &ldquo;jvm.h&rdquo;</h1>

<h1>include &ldquo;java_lang_String.h&rdquo;</h1>

<p>JNIEXPORT jobject JNICALL
Java_java_lang_String_intern(JNIEnv *env, jobject this)
{
return JVM_InternString(env, this);
}
```</p>

<!--more-->


<p><code>Java_java_lang_String_intern</code> 就是String类intern 对应的native方法,然而<code>Java_java_lang_String_intern</code> 只是调用了<code>JVM_InternString</code>这个方法。<br/>
那么这个方法又在哪呢？<br/>
根据经验我们发现<code>String.c</code> 引入了<code>jvm.h</code>，去<code>jvm.h</code>中去看一下。<code>jvm.h</code> 位于<code>openjdk/jdk/src/share/javavm/export</code> 下面，<code>jvm.h</code>中正好定义了我们要找的<code>JVM_InternString</code><br/>
<code>java
/*
* java.lang.String
* */
JNIEXPORT jstring JNICALL
JVM_InternString(JNIEnv *env, jstring str);
</code><br/>
这里只是定义,我们继续找这个定义对应的实现方法。相关实现在<code>jvm.cpp</code>中,<code>jvm.cpp</code> 位于：<code>openjdk/hotspot/src/share/vm/prims</code> 目录中。<code>jvm.cpp</code> 中<code>JVM_InternString</code>的具体实现如下:<br/>
<code>java
JVM_ENTRY(jstring, JVM_InternString(JNIEnv *env, jstring str))
JVMWrapper("JVM_InternString");
JvmtiVMObjectAllocEventCollector oam;
if (str == NULL) return NULL;
oop string = JNIHandles::resolve_non_null(str);
oop result = StringTable::intern(string, CHECK_NULL);
return (jstring) JNIHandles::make_local(env, result);
JVM_END
</code>
从上面的代码我们可以看出，实际上<code>JVM_InternString</code> 又调用了<code>StringTable</code> 的 <code>intern</code> 方法。<code>StringTable</code> 是在<code>symbolTable.hpp</code>  中被声明的，代码：<br/>
<code>java
class StringTable : public Hashtable&lt;oop, mtSymbol&gt; {
  friend class VMStructs;
private:
  // The string table
  static StringTable* _the_table;
.......
</code>
我们先简单看一下<code>StringTable</code>这个类： <br/>
1.  继承了Hashtable&lt;oop, mtSymbol>，在Hashtable中，字符串被包装成HashtableEntry对象存储，同时为了解决hash碰撞的问题，HashtableEntry对象被设计为链表结构。最后HashTable使用数组_buckets来存储这些HashtableEntry。 <br/>
2. <code>static StringTable* _the_table</code> : StringTable的实例变量,在<code>create_table()</code> 中被实例化。<br/>
3. <code>lookup(...)</code>: 用来查找常量池中是否包含某个实例。<br/>
4. <code>basic_add(...)</code>: 往常量池中添加新实例。<br/>
5. <code>intern(...)</code>: 判断常量池中是否有某个实例，有则返回该实例，没有则调用<code>basic_add</code> 添加。</p>

<p>看一下intern方法:<br/>
```java</p>

<p>oop StringTable::intern(Handle string_or_null, jchar* name,</p>

<pre><code>                    int len, TRAPS) {
</code></pre>

<p>  unsigned int hashValue = hash_string(name, len);
  int index = the_table()&ndash;>hash_to_index(hashValue);
  oop string = the_table()&ndash;>lookup(index, name, len, hashValue);</p>

<p>  // Found
  if (string != NULL) return string;</p>

<p>  // Otherwise, add to symbol to table
  return the_table()&ndash;>basic_add(index, string_or_null, name, len,</p>

<pre><code>                            hashValue, CHECK_NULL);
</code></pre>

<p>}
<code>
第3行:首先调用hash_string()计算字符串的hash值。hash值计算规则:`s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]` 例如：`“a”.hashCode() = 97`。代码:  
</code>java
int StringTable::hash_string(jchar* s, int len) {
  unsigned h = 0;
  while (len&mdash; > 0) {</p>

<pre><code>h = 31*h + (unsigned) *s;
s++;
</code></pre>

<p>  }
  return h;
}
<code>
第4行:把hash值转换为数组的下标。转换规则：`hash % table_size`。代码:  
</code>java
int hash_to_index(unsigned int full_hash) {</p>

<pre><code>int h = full_hash % _table_size;
assert(h &gt;= 0 &amp;&amp; h &lt; _table_size, "Illegal hash value");
return h;
</code></pre>

<p>  }
<code>
第5行:检查该字符串是否存在，如果存在，就返回。代码:
</code>java
oop StringTable::lookup(int index, jchar* name,</p>

<pre><code>                    int len, unsigned int hash) {
</code></pre>

<p>  for (HashtableEntry* l = bucket(index); l != NULL; l = l->next()) {</p>

<pre><code>if (l-&gt;hash() == hash) {
  if (java_lang_String::equals(l-&gt;literal(), name, len)) {
    return l-&gt;literal();
  }
}
</code></pre>

<p>  }
  return NULL;
}
```
说明:<br/>
1.首先从数组_buckets获得当前下标对应的HashtableEntry。 <br/>
2.判断该entry的hash值和字符串值是否都相等(是不是很眼熟)，如果都相等则返回该entry中存储的字符串对象。<br/>
3.如果(2)条件不成立则继续循环next entry。</p>

<p>第11行:调用StringTable的<code>basic_add(...)</code>方法将字符串添加到常量池。代码:<br/>
```java
oop StringTable::basic_add(int index, Handle string_or_null, jchar* name,</p>

<pre><code>                       int len, unsigned int hashValue, TRAPS) {
</code></pre>

<p>  debug_only(StableMemoryChecker smc(name, len * sizeof(name[0])));
  assert(!Universe::heap()&ndash;>is_in_reserved(name) || GC_locker::is_active(),</p>

<pre><code>     "proposed name of symbol must be stable");
</code></pre>

<p>  Handle string;
  // try to reuse the string if possible
  if (!string_or_null.is_null() &amp;&amp; string_or_null()&ndash;>is_perm()) {</p>

<pre><code>string = string_or_null;
</code></pre>

<p>  } else {</p>

<pre><code>string = java_lang_String::create_tenured_from_unicode(name, len, CHECK_NULL);
</code></pre>

<p>  }</p>

<p>  // Allocation must be done before grapping the SymbolTable_lock lock
  MutexLocker ml(StringTable_lock, THREAD);</p>

<p>  assert(java_lang_String::equals(string(), name, len),</p>

<pre><code>     "string must be properly initialized");
</code></pre>

<p>  // Since look-up was done lock-free, we need to check if another
  // thread beat us in the race to insert the symbol.</p>

<p>  oop test = lookup(index, name, len, hashValue); // calls lookup(u1*, int)
  if (test != NULL) {</p>

<pre><code>// Entry already added
return test;
</code></pre>

<p>  }</p>

<p>  HashtableEntry* entry = new_entry(hashValue, string());
  add_entry(index, entry);
  return string();
}
```</p>

<p>第12行:创建一个String对象,创建过程可以参考<code>openjdk/hotspot/src/share/vm/classfile/javaClasses.cpp</code>中<code>java_lang_String</code>类的<code>create_tenured_from_unicode</code>方法。后面要单独讲对象的创建过程，这里就不展开了，后面文章写完了，会把链接贴过来。<br/>
第30行:创建一个HashtableEntry对象。<br/>
第31行: 将新创建的Sting对象添加到常量池<code>_buckets</code>中。代码:<br/>
<code>java
inline void BasicHashtable::add_entry(int index, BasicHashtableEntry* entry) {
  entry-&gt;set_next(bucket(index));
  _buckets[index].set_entry(entry);
  ++_number_of_entries;
}
</code>
说明:<br/>
1.首先从<code>_buckets</code>数组获得index位置的HashtableEntry 记为oldEntry。 <br/>
2.将oldEntry设置为entry的<code>_next</code>(HashtableEntry设计为链表结构,就是用在这里)<br/>
3.将entry设置到_buckets的index位置</p>

<h3>总结:</h3>

<p>String常量池对应的数据结构就是StringTable对象,也就是一个Hashtable结构。hashtable的结构是数组+链表。hashtable一直持有字符串的引用，因此字符串池中的对象不会被垃圾收集器回收掉。<br/>
Hashtable 的结构看起来应该是这样的：<br/>
<img src="/images/blog/2014-06/20140602-hashtable.png" alt="Hasttable" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM 之 String 常量池 一]]></title>
    <link href="http://blog.zarue.com//blog/2014/05/27/runtime-string-pool-1/"/>
    <updated>2014-05-27T20:30:20+08:00</updated>
    <id>http://blog.zarue.com//blog/2014/05/27/runtime-string-pool-1</id>
    <content type="html"><![CDATA[<h4>1.Sting对象创建方式</h4>

<p>JAVA里面创建字符串有两种方式：<br/>
1. 通过字符串常量方式:String a = &ldquo;a&rdquo;;<br/>
2. 通过new 关键字创建:new String(&ldquo;a&rdquo;);</p>

<p>但是这两种创建字符串的方式有很大的不同。<br/>
1. 使用第一种方式，jvm首先会检查字符串常量池中是否存在了这个常量，如果存在，就返回池中的实例引用。如果不存在，就会实例化一个字符串并放到池中,然后返回引用。<br/>
2. 使用第二种方式，则直接分配到heap中，不指向字符串常量池中的任何对象，和字符串常量池没有关系。</p>

<h4>2.下面来看一个例子: <a href="https://gist.github.com/zarue/25e0afedb33de86da650">本例子Gist地址</a></h4>

<!--more-->


<p>```java
public class StringConstantTest {</p>

<pre><code>public static String str_0_static = "a";
public String str_0 = "a";

public static void main(String args[]){

    StringConstantTest sct = new StringConstantTest();
    //同package对象
    StringConstantTest1 sct1 = new StringConstantTest1();
    //不同package对象
    StringConstantTest2 sct2 = new StringConstantTest2();

    String str0 = "a";
    String str1 = "b";
    String str2 = "ab";
    String str3 = "a"+"b";
    String str4 = str0 + str1;
    String str5 = str0 + "b";
    String str6 = new String("ab");
    String str7 = new String("ab");
    String str8 = new String(str4);

    //局部变量和成员变量
    System.out.println("str0==sct.str_0: "+(str0 == sct.str_0));
    System.out.println("str0==sct1.str_0: "+(str0 == sct1.str_0));
    System.out.println("str0==sct2.str_0: "+(str0 == sct2.str_0));

    //局部变量和静态变量
    System.out.println("str0==str_0_static： "+(str0 == str_0_static));
    System.out.println("str0==StringConstantTest1.str_0_static: "+(str0 == StringConstantTest1.str_0_static));
    System.out.println("str0==StringConstantTest2.str_0_static: "+(str0 == StringConstantTest2.str_0_static));

    //局部变量
    System.out.println("str2==str3: "+(str2 == str3));
    System.out.println("str2==str4: "+(str2 == str4));
    System.out.println("str2==str5: "+(str2 == str5));

    //局部变量和对象
    System.out.println("str2==str6: "+(str2 == str6));
    System.out.println("str2==str7: "+(str2 == str7));
    System.out.println("str2==str8: "+(str2 == str8));

    //对象和对象 intern
    System.out.println("str2==str6.intern(): "+(str2 == str6.intern()));
    System.out.println("str7.intern()==str6.intern(): "+(str7.intern() == str6.intern()));
    System.out.println("str8.intern()==str6.intern(): "+(str8.intern() == str6.intern()));

    //对象和对象equals
    System.out.println("str6.equals(str7): "+str6.equals(str7));
    System.out.println("str2.equals(str6): "+str2.equals(str6));
}
</code></pre>

<p>}</p>

<p>class StringConstantTest1 {</p>

<pre><code>public String str_0 = "a";
public static String str_0_static = "a";
</code></pre>

<p>}
```</p>

<p><img src="/images/blog/2014-05/20140528-string-pool-1.png" alt="结果" /></p>

<h4>分析(下面所指行号均为源代码行号):</h4>

<ol>
<li><p><strong>24-31</strong>行的结果说明:<br/>
只要是字符串常量方式创建的对象，无论是类变量，实例变量，还是局部变量，无论是不是位于同一个包中。都是共享字符串常量池中的同一个实例。</p></li>
<li><p><strong>34</strong>行为true, 是因为:<br/>
String str3 = &ldquo;a&rdquo;+&ldquo;b&rdquo;; 是因为“a” 和 “b” 都是常量，编译器在编译阶段会直接优化为String str3 = &ldquo;ab"。<br/>
可以通过javap 反编译class字节码来看一下:<br/>
<code>
30: astore 5
32: ldc #35 // String ab
34: astore 6
36: ldc #35 // String ab
</code>
上面第36行就是<code>String str3 = "a"+"b";</code>对应的字节码。这里可以看出"a&rdquo;+&ldquo;b"已经被优化为"ab"了。</p></li>
<li><p><strong>35</strong>行为false, 是因为:<br/>
String str4 = str0 + str1; 是因为str0 和 str1 都是变量，需要运行期才能转换为对应的值，而且String 会把变量的+操作，转换成StringBuilder的append操作,然后返回一个新的String对象。<br/>
再看一下字节码文件:</p></li>
</ol>


<p><code>
40: new #37 // class java/lang/StringBuilder
43: dup
44: aload 4
46: invokestatic #39 // Method java/lang/String.valueOf:(Ljava/lang/Object;)Ljava/lang/String;
49: invokespecial #45 // Method java/lang/StringBuilder."&lt;init&gt;":(Ljava/lang/String;)V
52: aload 5
54: invokevirtual #48 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
57: invokevirtual #52 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
60: astore 8
</code>
由上面的字节码可以看出<code>String str4 = str0 + str1;</code>  相当于:<br/>
<code>
StringBuilder sb = new Stringbuilder(str0);  
sb.append(str1);  
sb.toString();  
</code>
再看一下StringBuilder的toString()方法:<br/>
<code>
public String toString() {
// Create a copy, don't share the array
return new String(value, 0, count);
}
</code>
由以上代码可已看出，toString()是new了一个String对象返回，所以是直接分配在heap上。因此结果为false。</p>

<ol>
<li><strong>39-41</strong>行为false: 是因为:<br/>
str6,str7,str8 都是通过new 创建，数据分配到heap上面，不指向字符串常量池中的任何对象，所以三个对象均不同，引用自然不同，因此比较结果均为false。</li>
<li><p><strong>44-46</strong>行为true: 是因为:<br/>
当一个String实例str调用intern()方法时，Java查找字符串常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用。所以上面均为true。</p></li>
<li><p><strong>49-50</strong>行为true: 是因为:<br/>
String的值是用char数组保存的，equals 是比较的两个String对象中的char数组值是否一致，所以两个结果为true。<br/>
看一下String的equals方法:<br/>
<code>
public boolean equals(Object anObject) {
     if (this == anObject) {
         return true;
     }
     if (anObject instanceof String) {
         String anotherString = (String) anObject;
         int n = value.length;
         if (n == anotherString.value.length) {
             char v1[] = value;
             char v2[] = anotherString.value;
             int i = 0;
             while (n-- != 0) {
                 if (v1[i] != v2[i])
                         return false;
                 i++;
             }
             return true;
         }
     }
     return false;
 }
</code></p></li>
</ol>


<h5>下一节<a href="/blog/2014/05/29/runtime-string-pool-2/">JVM 之 String常量池二</a>将会详细讲一下字符串池的结构以及原理</h5>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM 之 Java 对象结构]]></title>
    <link href="http://blog.zarue.com//blog/2014/05/22/jvm-object-structure/"/>
    <updated>2014-05-22T14:09:15+08:00</updated>
    <id>http://blog.zarue.com//blog/2014/05/22/jvm-object-structure</id>
    <content type="html"><![CDATA[<h2>1. Java对象在内存中到底是什么样?</h2>

<p>JAVA对象在内存中的表现形式就是一系列按照<em>某种规范</em>排列的字节(如果不清楚物理内存j的实现方式，请参考：<a href="http://blog.zarue.com/blog/2014/05/21/cpu-and-memory/">关于CPU寻址和物理内存结构</a> )。
那在JVM中这个规范是怎么定义的呢？
Hotspot虚拟机中，对象分为两大类：普通对象和数组对象，两类对象在内存中的布局可以分为三部分:<code>对象头，对象实例数据， 对齐填充</code> 。不同的是普通对象的对象头是由<code>MARK WORD，CLASS对象指针</code>两部分组成，而数组对象头是由<code>MARK WORD，CLASS对象指针，数组长度</code>三部分组成，如图:<br/>
<img src="/images/blog/2014-05/20140524-object-arrayObject-structure.png" alt="对象结构" /></p>

<!--more-->


<h4>1.首先看一下对象头的具体结构(表格中的“长度“同时标明了32位和64位虚拟机):</h4>

<table>
<thead>
<tr>
<th align="center">内容</th>
<th align="center">长度</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">  Mark Word  </td>
<td align="center">  32/64bit  </td>
<td align="left">  存储对象的hashCode或锁信息等。</td>
</tr>
<tr>
<td align="center">  Class对象指针  </td>
<td align="center">  32/64bit  </td>
<td align="left">  存储到对象类型数据的指针</td>
</tr>
<tr>
<td align="center">  数组长度  </td>
<td align="center">  32/64bit  </td>
<td align="left">  数组的长度（如果当前对象是数组）</td>
</tr>
</tbody>
</table>


<p>Java对象头里的Mark Word里默认存储对象的HashCode，分代年龄和锁标记位。32位JVM的Mark Word的默认存储结构(无锁状态)如下：</p>

<table>
<thead>
<tr>
<th align="center">锁状态</th>
<th align="center">25 bit</th>
<th align="left"> 4 bit</th>
<th align="left">1 bit是否是偏向锁</th>
<th align="left">2 bit锁标志位</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"> 无锁状态</td>
<td align="center">对象的hashCode</td>
<td align="left">对象分代年龄</td>
<td align="left">0</td>
<td align="left">01</td>
</tr>
</tbody>
</table>


<p>在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据：<code>轻量级锁</code>，<code>重量级锁</code>，<code>GC标记</code> ，<code>偏向锁</code>。本文只讨论对象结构，如果想详细了解对象锁，可以参考:<a href="http://ifeve.com/java-synchronized/">Java SE1.6中的Synchronized</a></p>

<h4>2.对象实例数据：</h4>

<p>实例数据包括自身的实例变量和从父类继承的实例变量，这些变量的排序顺序受虚拟机分配策略参数（FieldsAllocationStyle）和字段在源代码中定义的顺序影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers）。从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认为true），那子类之中较窄的变量也可能会插入到父类变量的空隙之中。</p>

<h4>3.对齐填充数据：</h4>

<p>对齐填充数据不是必须的，它仅仅起着占位的作用。HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。对象头部分正好似8字节的倍数（1倍或者2倍），因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>

<h2>2. 现在我们就通过实例来看一下JVM中的对象结构是不是和上面所述一样呢?</h2>

<p>说明:下面的实验我们将用到Hotspot提供的虚拟机调试工具ServiceAbility Agent。如果不太熟悉该工具可以参考:<a href="http://rednaxelafx.iteye.com/blog/1847971">借HSDB来探索HotSpot VM的运行时数据</a><br/>
环境:Ubuntu 14.04 32bit</p>

<h4>1.先看一段简单代码：</h4>

<p>```java
public class Animal {</p>

<pre><code>public static void main(String args[]){
    Integer i = new Integer(1);
    Long l = new Long(2);
    Boolean b = new Boolean(true);
    System.out.println(""); 
}
</code></pre>

<p>}
```</p>

<p>main方法里面包含3个对象：<code>Integer</code>,<code>Long</code>,<code>Boolean</code> ，我们现在通过SA依次来看一下每一个对象的结构和大小：<br/>
1.运行上面的程序，在<code>System.out.println("")</code>这行打个断点是虚拟机进程暂停<br/>
2.使用JPS查看虚拟机进程PID:<br/>
<img src="/images/blog/2014-05/20140524-objectsize-jps.png" alt="jps截图" /><br/>
3.启动SA(HSDB)<br/>
<code>sudo java -cp $JAVA_HOME/lib/sa-jdi.jar sun.jvm.hotspot.HSDB</code><br/>
4.attach 上面的PID 3813,连上之后我们进入内存查看界面，如图:</p>

<p><img src="/images/blog/2014-05/20140524-hsdb-memory.png" alt="内存查看" /></p>

<p>红色方框中的内容就是main方法中我们new的三个对象，通过右边的注释我们也可以看出来。<br/>
三个对象在内存中的地址分别是：</p>

<blockquote><p>Integer i &nbsp;&nbsp;&nbsp; 0xa0159410<br/>
Long l  &nbsp;&nbsp;&nbsp; 0xa0159520<br/>
Boolean b &nbsp;&nbsp;&nbsp;0xa0159650</p></blockquote>

<p>首先我们先看Integer i 对象,选择SA中的菜单:<code>Tool--&gt;Inspect</code>子菜单,在address中输入<code>0xa0159410</code>可以得到这个对象，如图:<br/>
<img src="/images/blog/2014-05/20140524-hsdb-memory-integer.png" alt="Integer对象内存结构" /></p>

<p>按照刚才得方法，接下来我们看一下Long l 对象，如图：<br/>
<img src="/images/blog/2014-05/20140524-hsdb-memory-long.png" alt="Long对象内存结构" /></p>

<p>再看一下Boolean b 对象,如图:<br/>
<img src="/images/blog/2014-05/20140524-hsdb-memory-boolean.png" alt="Boolean对象内存结构" /></p>

<p>小结:因为对象实例数据只包括实例变量和从父类继承得实例变量，通过查看Integer,Long,Boolean 的源代码可知，这几个类只有value 一个实例变量，所以除了<em>mark(MARK_WORD),</em>metadata._klass(class对象指针)，我们只能看到一个value变量。</p>

<h4>2.现在我们看一个复杂点的:</h4>

<p>```java
public class Animal {</p>

<pre><code>Integer age = new Integer(1);
Long height = new Long(2);
Boolean sex = new Boolean(true);
public static void main(String args[]){
    System.out.println(""); 
}
</code></pre>

<p>}
```<br/>
我们看一下Animal的对象结构,如图:<br/>
<img src="/images/blog/2014-05/20140524-hsdb-memory-animal.png" alt="Animal对象内存结构" /></p>

<p>由图可以看出，三个实例变量都在对象Animal里面了。</p>

<h4>3.我们再看一个继承的:</h4>

<p>```java
public class Tiger extends Animal{</p>

<pre><code>public Double weight;
public static void main(String args[]){
    Tiger tiger = new Tiger();
    System.out.println(""); 
}
</code></pre>

<p>}
```
用HSDB查看结果，如图:<br/>
<img src="/images/blog/2014-05/20140524-hsdb-memory-tiger.png" alt="Tiger对象内存结构" /></p>

<p>由图可见，从父类继承的变量也是存在子类里面的。</p>

<h4>4.最后看一个数组的:</h4>

<p>```java
public class Tiger extends Animal{</p>

<pre><code>public Double wight;
public Integer[] childs = new Integer[0];
public static void main(String args[]){
    Tiger tiger = new Tiger();
    System.out.println(""); 
}
</code></pre>

<p>}
```
用HSDB查看,结果如图:<br/>
<img src="/images/blog/2014-05/20140524-hsdb-memory-array.png" alt="数组对象内存结构" /></p>

<p>不幸的事情出现了，为什么这个数组对象没有显示length变量呢？难道我们之前说的数组对象的结构式错的？<br/>
用inspect 查看一下这个对象的size:<br/>
<code>inspect 0xa01ba470</code> 结果如图所示：<br/>
<img src="/images/blog/2014-05/20140524-hsdb-memory-array-size.png" alt="数组对象size" /></p>

<p>我们来算一下:<br/>
1. 如果这个对象没有length变量，那么大小应该是：size=4+4=8.<br/>
2. 如果这个对象有length，那么大小应该是：size=4+4+4+4(补全)=16,和刚才截图中的一样。所以这个length肯定是有的，至于为什么没显示出来，我觉得有可能是这个SA插件得bug。</p>

<p>总结：通过SA我们可以查看JVM内部的实时数据，这对我们学习JVM是一个很有利的工具，了解对象的结构是万里长征迈出的第一步。<br/>
参考文章:<br/>
<a href="http://rednaxelafx.iteye.com/blog/1847971">http://rednaxelafx.iteye.com/blog/1847971</a><br/>
<a href="http://ifeve.com/java-synchronized/">http://ifeve.com/java-synchronized/</a><br/>
<a href="http://icyfenix.iteye.com/blog/1145044">http://icyfenix.iteye.com/blog/1145044</a></p>
]]></content>
  </entry>
  
</feed>
