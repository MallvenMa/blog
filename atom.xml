<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[zarue]]></title>
  <link href="http://zarue.github.io//atom.xml" rel="self"/>
  <link href="http://zarue.github.io//"/>
  <updated>2014-05-24T18:03:05+08:00</updated>
  <id>http://zarue.github.io//</id>
  <author>
    <name><![CDATA[YungHua.Ma]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JVM 之 Java 对象结构]]></title>
    <link href="http://zarue.github.io//blog/2014/05/22/jvm-object-structure/"/>
    <updated>2014-05-22T14:09:15+08:00</updated>
    <id>http://zarue.github.io//blog/2014/05/22/jvm-object-structure</id>
    <content type="html"><![CDATA[<h2 id="1.-java对象在内存中到底是什么样?">1. Java对象在内存中到底是什么样?</h2>

<p>JAVA对象在内存中的表现形式就是一系列按照<em>某种规范</em>排列的字节(如果不清楚物理内存j的实现方式，请参考：<a href="http://blog.zarue.com/blog/2014/05/21/cpu-and-memory/">关于CPU寻址和物理内存结构</a> )。
那在JVM中这个规范是怎么定义的呢？
Hotspot虚拟机中，对象分为两大类：普通对象和数组对象，两类对象在内存中的布局可以分为三部分:<code>对象头，对象实例数据， 对齐填充</code> 。不同的是普通对象的对象头是由<code>MARK WORD，CLASS对象指针</code>两部分组成，而数组对象头是由<code>MARK WORD，CLASS对象指针，数组长度</code>三部分组成，如图:<br>
<img src="http://zarue.github.io//images/blog/2014-05/20140524-object-arrayObject-structure.png" alt="对象结构">  </p>

<h4 id="1.首先看一下对象头的具体结构(表格中的“长度“同时标明了32位和64位虚拟机):">1.首先看一下对象头的具体结构(表格中的“长度“同时标明了32位和64位虚拟机):</h4>

<table><thead>
<tr>
<th style="text-align: center">内容</th>
<th style="text-align: center">长度</th>
<th style="text-align: left">说明</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">Mark Word</td>
<td style="text-align: center">32/64bit</td>
<td style="text-align: left">存储对象的hashCode或锁信息等。</td>
</tr>
<tr>
<td style="text-align: center">Class对象指针</td>
<td style="text-align: center">32/64bit</td>
<td style="text-align: left">存储到对象类型数据的指针</td>
</tr>
<tr>
<td style="text-align: center">数组长度</td>
<td style="text-align: center">32/64bit</td>
<td style="text-align: left">数组的长度（如果当前对象是数组）</td>
</tr>
</tbody></table>

<p>Java对象头里的Mark Word里默认存储对象的HashCode，分代年龄和锁标记位。32位JVM的Mark Word的默认存储结构(无锁状态)如下：  </p>

<table><thead>
<tr>
<th style="text-align: center">锁状态</th>
<th style="text-align: center">25 bit</th>
<th style="text-align: left">4 bit</th>
<th style="text-align: left">1 bit是否是偏向锁</th>
<th style="text-align: left">2 bit锁标志位</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">无锁状态</td>
<td style="text-align: center">对象的hashCode</td>
<td style="text-align: left">对象分代年龄</td>
<td style="text-align: left">0</td>
<td style="text-align: left">01</td>
</tr>
</tbody></table>

<p>在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据：<code>轻量级锁</code>，<code>重量级锁</code>，<code>GC标记</code> ，<code>偏向锁</code>。本文只讨论对象结构，如果想详细了解对象锁，可以参考:<a href="http://ifeve.com/java-synchronized/">Java SE1.6中的Synchronized</a>  </p>

<h4 id="2.对象实例数据：">2.对象实例数据：</h4>

<p>实例数据包括自身的实例变量和从父类继承的实例变量，这些变量的排序顺序受虚拟机分配策略参数（FieldsAllocationStyle）和字段在源代码中定义的顺序影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers）。从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认为true），那子类之中较窄的变量也可能会插入到父类变量的空隙之中。   </p>

<h4 id="3.对齐填充数据：">3.对齐填充数据：</h4>

<p>对齐填充数据不是必须的，它仅仅起着占位的作用。HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。对象头部分正好似8字节的倍数（1倍或者2倍），因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。   </p>

<h2 id="2.-现在我们就通过实例来看一下jvm中的对象结构是不是和上面所述一样呢?">2. 现在我们就通过实例来看一下JVM中的对象结构是不是和上面所述一样呢?</h2>

<p>说明:下面的实验我们将用到Hotspot提供的虚拟机调试工具ServiceAbility Agent。如果不太熟悉该工具可以参考:<a href="http://rednaxelafx.iteye.com/blog/1847971">借HSDB来探索HotSpot VM的运行时数据</a><br>
环境:Ubuntu 14.04 32bit  </p>

<h4 id="1.先看一段简单代码：">1.先看一段简单代码：</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">[]){</span>
</span><span class='line'>      <span class="n">Integer</span> <span class="n">i</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>      <span class="n">Long</span> <span class="n">l</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Long</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
</span><span class='line'>      <span class="n">Boolean</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Boolean</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span><span class='line'>      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">);</span> 
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>main方法里面包含3个对象：<code>Integer</code>,<code>Long</code>,<code>Boolean</code> ，我们现在通过SA依次来看一下每一个对象的结构和大小：<br>
1.运行上面的程序，在<code>System.out.println(&quot;&quot;)</code>这行打个断点是虚拟机进程暂停<br>
2.使用JPS查看虚拟机进程PID:<br>
<img src="http://zarue.github.io//images/blog/2014-05/20140524-objectsize-jps.png" alt="jps截图"><br>
3.启动SA(HSDB)<br>
<code>sudo java -cp $JAVA_HOME/lib/sa-jdi.jar sun.jvm.hotspot.HSDB</code><br>
4.attach 上面的PID 3813,连上之后我们进入内存查看界面，如图:  </p>

<p><img src="http://zarue.github.io//images/blog/2014-05/20140524-hsdb-memory.png" alt="内存查看"></p>

<p>红色方框中的内容就是main方法中我们new的三个对象，通过右边的注释我们也可以看出来。<br>
三个对象在内存中的地址分别是：  </p>

<blockquote>
<p>Integer i &nbsp;&nbsp;&nbsp; 0xa0159410<br>
Long l  &nbsp;&nbsp;&nbsp; 0xa0159520<br>
Boolean b &nbsp;&nbsp;&nbsp;0xa0159650  </p>
</blockquote>

<p>首先我们先看Integer i 对象,选择SA中的菜单:<code>Tool--&gt;Inspect</code>子菜单,在address中输入<code>0xa0159410</code>可以得到这个对象，如图:<br>
<img src="http://zarue.github.io//images/blog/2014-05/20140524-hsdb-memory-integer.png" alt="Integer对象内存结构"></p>

<p>按照刚才得方法，接下来我们看一下Long l 对象，如图：<br>
<img src="http://zarue.github.io//images/blog/2014-05/20140524-hsdb-memory-long.png" alt="Long对象内存结构"></p>

<p>再看一下Boolean b 对象,如图:<br>
<img src="http://zarue.github.io//images/blog/2014-05/20140524-hsdb-memory-boolean.png" alt="Boolean对象内存结构"></p>

<p>小结:因为对象实例数据只包括实例变量和从父类继承得实例变量，通过查看Integer,Long,Boolean 的源代码可知，这几个类只有value 一个实例变量，所以除了<u>mark(MARK</u>WORD),<u>metadata.</u>klass(class对象指针)，我们只能看到一个value变量。</p>

<h4 id="2.现在我们看一个复杂点的:">2.现在我们看一个复杂点的:</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">Integer</span> <span class="n">age</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>  <span class="n">Long</span> <span class="n">height</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Long</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
</span><span class='line'>  <span class="n">Boolean</span> <span class="n">sex</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Boolean</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">[]){</span>
</span><span class='line'>      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">);</span> 
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>  

<p>我们看一下Animal的对象结构,如图:<br>
<img src="http://zarue.github.io//images/blog/2014-05/20140524-hsdb-memory-animal.png" alt="Animal对象内存结构"></p>

<p>由图可以看出，三个实例变量都在对象Animal里面了。</p>

<h4 id="3.我们再看一个继承的:">3.我们再看一个继承的:</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Tiger</span> <span class="kd">extends</span> <span class="n">Animal</span><span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">Double</span> <span class="n">weight</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">[]){</span>
</span><span class='line'>      <span class="n">Tiger</span> <span class="n">tiger</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Tiger</span><span class="o">();</span>
</span><span class='line'>      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">);</span> 
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>用HSDB查看结果，如图:<br>
<img src="http://zarue.github.io//images/blog/2014-05/20140524-hsdb-memory-tiger.png" alt="Tiger对象内存结构"></p>

<p>由图可见，从父类继承的变量也是存在子类里面的。</p>

<h4 id="4.最后看一个数组的:">4.最后看一个数组的:</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Tiger</span> <span class="kd">extends</span> <span class="n">Animal</span><span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">Double</span> <span class="n">wight</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">Integer</span><span class="o">[]</span> <span class="n">childs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">[]){</span>
</span><span class='line'>      <span class="n">Tiger</span> <span class="n">tiger</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Tiger</span><span class="o">();</span>
</span><span class='line'>      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">);</span> 
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>用HSDB查看,结果如图:<br>
<img src="http://zarue.github.io//images/blog/2014-05/20140524-hsdb-memory-array.png" alt="数组对象内存结构"></p>

<p>不幸的事情出现了，为什么这个数组对象没有显示length变量呢？难道我们之前说的数组对象的结构式错的？<br>
用inspect 查看一下这个对象的size:<br>
<code>inspect 0xa01ba470</code> 结果如图所示：<br>
<img src="http://zarue.github.io//images/blog/2014-05/20140524-hsdb-memory-array-size.png" alt="数组对象size"></p>

<p>我们来算一下:<br>
1. 如果这个对象没有length变量，那么大小应该是：size=4+4=8.<br>
2. 如果这个对象有length，那么大小应该是：size=4+4+4+4(补全)=16,和刚才截图中的一样。所以这个length肯定是有的，至于为什么没显示出来，我觉得有可能是这个SA插件得bug。  </p>

<p>总结：通过SA我们可以查看JVM内部的实时数据，这对我们学习JVM是一个很有利的工具，了解对象的结构是万里长征迈出的第一步。<br>
参考文章:<br>
<a href="http://rednaxelafx.iteye.com/blog/1847971">http://rednaxelafx.iteye.com/blog/1847971</a><br>
<a href="http://ifeve.com/java-synchronized/">http://ifeve.com/java-synchronized/</a><br>
<a href="http://icyfenix.iteye.com/blog/1145044">http://icyfenix.iteye.com/blog/1145044</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于CPU寻址和物理内存结构]]></title>
    <link href="http://zarue.github.io//blog/2014/05/21/cpu-and-memory/"/>
    <updated>2014-05-21T20:35:18+08:00</updated>
    <id>http://zarue.github.io//blog/2014/05/21/cpu-and-memory</id>
    <content type="html"><![CDATA[<h2 id="本文讨论的都是概念模型，实际实现方式肯定会有不同">本文讨论的都是概念模型，实际实现方式肯定会有不同</h2>

<h3 id="1.-关于cpu的几个概念">1. 关于CPU的几个概念</h3>

<ol>
<li>数据总线：数据总线是CPU和其它组件（比如：内存）之间进行数据交互的通道。<br></li>
<li>数据总线宽度：是指CPU中寄存器的位数，即CPU位数，我们常说的32位，64位就是指的这个参数。CPU的位数和CPU的寻址能力没有关系。我们之前经常听到32位的CPU最大寻址能力是2^32 因此它最大可识别的内存是4G，64位CPU可以识别4G以上内存，其实这是不正确的，因为CPU的寻址能力和CPU的位数没有关系。<br></li>
<li>地址总线：CPU是通过地址总线来进行内存寻址。<br></li>
<li>地址总线宽度：地址总线宽度决定了CPU的寻址范围，如果地址总线是32位，那么该CPU的寻址范围就是0-2^32-1（0x00000000-0xFFFFFFFF），也就是4G个存储单元，如果存储单元是按字节编址，那么CPU可以寻址的最大内存量就是4G(byte)，这时候即使有再大的内存也不会被识别。<br></li>
<li>控制总线：主要是将CPU的控制指令传送到其它组件 </li>
</ol>

<p>关于总线更详细的文章网上有很多，例如：  </p>

<ul>
<li><a href="http://share.onlinesjtu.com/mod/tab/view.php?id=253">总线的内部结构</a><br></li>
<li><a href="http://my.oschina.net/u/158589/blog/70813">CPU位数，寻址能力，指令集，寄存器位数，操作系统位数</a><br></li>
</ul>

<h3 id="2.-关于内存的几个概念">2. 关于内存的几个概念</h3>

<ol>
<li>存储元：是存储器的最小存储单位，它可以存放一个二进制代码。</li>
<li>存储单元：若干个存储元构成一个存储单元，每个存储单元可以存放一个字节（按字节编址），或者存放一个字（按字编址）,当然理论上也存在按bit编址的可能，当然用的非常少。一个字是几个字节呢？这个看计算机的具体实现。</li>
<li>存储单元地址：每个存储单元的编号，一般用一个十六进制数来表示。CPU就是根据这个地址访问存储单元中的数据。</li>
<li>存储器：若干个存储单元构成一个存储器。</li>
</ol>

<p>关于内存更详细的文章网上也有很多，例如：  </p>

<ul>
<li><a href="http://www.baike.com/wiki/%E5%AD%98%E5%82%A8%E5%99%A8">互动百科-存储器</a><br></li>
</ul>

<p>总结：了解一下CPU和内存的底层结构，再去学习底层程序实现的时候就不会感到那么迷茫了（一个数据到底在内存中是怎么存的呢？）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac OSX vim 输入中文乱码问题]]></title>
    <link href="http://zarue.github.io//blog/2014/05/18/vim-chinese-error/"/>
    <updated>2014-05-18T22:05:24+08:00</updated>
    <id>http://zarue.github.io//blog/2014/05/18/vim-chinese-error</id>
    <content type="html"><![CDATA[<h3 id="出现问题的环境:">出现问题的环境:</h3>

<ol>
<li>OSX 10.9.2 英文<br></li>
<li>VIM 7.3<br></li>
</ol>

<h3 id="问题描述:">问题描述:</h3>

<ol>
<li>可以正常显示文件中得中文字符<br></li>
<li>输入中文字符会出现乱码<br></li>
<li>通过在.vimrc中设置编码格式无效<br></li>
</ol>

<h3 id="解决方案:">解决方案:</h3>

<p>找到 <code>Terminal--&gt;Preferences--&gt;Settings--&gt;Advanced--&gt;Escape non-ASCII input with Control-V</code> 取消该选项即可.<br>
如果你尝试了设置各种编码格式都无法解决乱码问题的话，可以尝试一下该方法<br>
如图:<br>
<img src="http://zarue.github.io//images/blog/2014-05/20140519-1-vim.png" alt="示例"></p>
]]></content>
  </entry>
  
</feed>
